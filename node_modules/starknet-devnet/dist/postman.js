"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Postman = void 0;
function numericToHexString(numeric) {
    return "0x" + BigInt(numeric).toString(16);
}
/**
 * https://0xspaceshard.github.io/starknet-devnet-rs/docs/postman
 */
class Postman {
    constructor(rpcProvider) {
        this.rpcProvider = rpcProvider;
    }
    /**
     * https://0xspaceshard.github.io/starknet-devnet-rs/docs/postman#flush
     */
    async flush(additionalArgs = { dryRun: false }) {
        return this.rpcProvider.sendRequest("devnet_postmanFlush", {
            dry_run: additionalArgs.dryRun,
        });
    }
    /**
     * https://0xspaceshard.github.io/starknet-devnet-rs/docs/postman#load
     */
    async loadL1MessagingContract(networkUrl, address, networkId) {
        return await this.rpcProvider.sendRequest("devnet_postmanLoad", {
            network_id: networkId,
            address,
            network_url: networkUrl,
        });
    }
    /**
     * https://0xspaceshard.github.io/starknet-devnet-rs/docs/postman#mock-transactions
     */
    async sendMessageToL2(l2ContractAddress, entryPointSelector, l1ContractAddress, payload, nonce, paidFeeOnL1) {
        return await this.rpcProvider.sendRequest("devnet_postmanSendMessageToL2", {
            l2_contract_address: l2ContractAddress,
            entry_point_selector: entryPointSelector,
            l1_contract_address: l1ContractAddress,
            payload: payload.map(numericToHexString),
            nonce: numericToHexString(nonce),
            paid_fee_on_l1: numericToHexString(paidFeeOnL1),
        });
    }
    /**
     * https://0xspaceshard.github.io/starknet-devnet-rs/docs/postman#l2-l1
     */
    async consumeMessageFromL2(fromAddress, toAddress, payload) {
        return await this.rpcProvider.sendRequest("devnet_postmanConsumeMessageFromL2", {
            from_address: fromAddress,
            to_address: toAddress,
            payload: payload.map(numericToHexString),
        });
    }
}
exports.Postman = Postman;
